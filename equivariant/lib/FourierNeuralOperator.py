'''
Contain a single class: the  Fourier Neural Operator for symmetry covariant convolutions + downsampling + upsampling
'''


import torch
import torch.nn as nn

from lib.SymmetryFactory import SymmetryFactory

from scipy.io import savemat

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")



class FourierNeuralOperator(nn.Module):
    def __init__(self, c1, c2, n2, make_kernel=True ):
        '''
        The goal of this network is to map a [b,c1,n1,n1] tensor to a [b,c2,n2,n2]
        (or the Fourier transformed equivalents)

        n1 is not passed to the constructor because this operator should handle arbitrary resolutions as inputs

        b  - batch size
        c1 - input channels
        c2 - output channels
        n2 - output grid resolution

        make_kernel - if False, there are no trainable parameters and you can freely use the upsample and downsample functions to get to desired resolutions.
        '''

        super().__init__()
        self.c1 = c1 #input channels
        self.c2 = c2 #output channels
        self.n2 = n2 #output grid resolution
        self.make_kernel = make_kernel

        print(f"Creating Fourier Neural Operator with output resolution {n2} and channel {c1} -> {c2}")

        #The only trainable parameter is the kernel, which will be stored at the output resolution.
        #amplitude of initialized kernels
        if make_kernel:
            epsilon = 1e-2 #Just make it small initially to break symmetry
            self.kernel = torch.nn.Parameter(  epsilon*(2*torch.rand(1, c1, c2, n2, n2)-1) )

    
    def symmetric_kernel(self):
        '''
        Symmetrize the kernel with respect to D4, the symmetry group of a square
        I'm usin gthe fact that D4 is generated by a reflection about the diagonal and 90 degree rotations
        '''

        if not self.make_kernel:
            print("Error: trying to call a kernel when you passed make_kernel=False")

        #Use this to apply symmetry operations since the storage of our data on a 
        #periodic grid makes applying these symmetries nontrivial
        symm = SymmetryFactory()

        #all rotations
        k1 = self.kernel
        k2 = symm.rot90_kernel( k1 )
        k3 = symm.rot90_kernel( k2 )
        k4 = symm.rot90_kernel( k3 )

        #one reflection + rotations
        k5 = symm.transpose(k1) #reflection about diagonal
        k6 = symm.rot90_kernel( k5 )
        k7 = symm.rot90_kernel( k6 )
        k8 = symm.rot90_kernel( k7 )
        
        #take the group mean
        k = (k1 + k2 + k3 + k4 + k5 + k6 + k7 + k8)/8
        return k


    def downsample(self, f, fourier_input=True, fourier_output=True):
        '''
        Reduce the spatial resolution by truncating a Fourier series
        '''

        n1 = f.shape[-2] #get input resolution
        n2 = self.n2

        if not fourier_input:
            f = torch.fft.fft2( f )
        
        #Create a new f that only samples the lower frequencies
        #To do this, create a Fourier wavenumber vector k
        k = torch.arange(n1)
        k[k>n1//2] = k[k>n1//2] - n1

        #Compute a boolean matrix for indexing the components we keep
        nyq = n2//2 #nyquist frequency of smaller grid
        keep = torch.abs(k) < nyq #Keep everything below nyquist 
        keep[ k == nyq ] = True # there is only one nyquist we keep. we discard the negative part

        keepx = torch.unsqueeze(keep, 1)
        keepy = torch.unsqueeze(keep, 0) 
        keep  = torch.logical_and( keepx, keepy )

        #Now flatten along these two dimensions so we can do everythiong with one boolean access
        f    = f.view( f.shape[0], f.shape[1], n1*n1 )
        keep = keep.view( n1*n1 )
        f    = f[..., keep] #do the subsampling in the collapsed index
        
        f    = f.view( f.shape[0], f.shape[1], n2, n2)

        # The nyquist modes need doubled since we only preserved half of the information
        # These scalings were determined empirically
        f[..., nyq,   :] *= 0 
        f[...,   :, nyq] *= 0
        #f[..., nyq, nyq] *= 0.5 
        
        #Renormalize the Fourier coefficients
        f = f * (n2 / n1)**2

        if not fourier_output:
            f = torch.fft.ifft2(f)
            f = torch.real(f)

        return f




    def upsample( self, f, fourier_input=True, fourier_output=True ):
        '''
        Reduce the spatial resolution by truncating a Fourier series
        '''

        n1 = f.shape[-2] #get input resolution
        n2 = self.n2

        if not fourier_input:
            f = torch.fft.fft2( f )
        
        #Create a new f with appropriate
        #To do this, create a Fourier wavenumber vector k
        k = torch.arange(n2)
        k[k>n2//2] = k[k>n2//2] - n2

        #Compute a boolean matrix for indexing the components we keep
        nyq = n1//2 #nyquist frequency of smaller grid
        keep = torch.abs(k) < nyq #Keep everything below nyquist 
        keep[ k == nyq ] = True # there is only one nyquist we keep. we discard the negative part

        keepx = torch.unsqueeze(keep, 1)
        keepy = torch.unsqueeze(keep, 0) 
        keep  = torch.logical_and( keepx, keepy )

        #allocate memory for the upsampled tensor
        f_big = torch.zeros( f.shape[0], f.shape[1], n2*n2, dtype=f.dtype )

        #Now flatten along these two dimensions so we can do everythiong with one boolean access
        f    = f.view(     f.shape[0], f.shape[1], n1*n1 )
        keep = keep.view( n2*n2 )
        f_big[..., keep] = f #do the subsampling in the collapsed index
        
        #At this point, reclaim the name f to mean out enhanced resolution field
        f = f_big.view( f.shape[0], f.shape[1], n2, n2  ) #reshape back to [b,c1,n2,n2]
        
        f[..., nyq,   :] *= 0 
        f[...,   :, nyq] *= 0

        #Renormalize the Fourier coefficients
        f = f * (n2 / n1)**2

        if not fourier_output:
            f = torch.fft.ifft2(f)
            f = torch.real(f)

        return f


    def convolution(self,f):
        if not self.make_kernel:
                print("Error: trying to call a kernel when you passed make_kernel=False")

        # Take f of size [b,c1,n1,n1] and convolve via fft2 + change sampling 
        # output [b,c2,n2,n2] 
        #
        # Both input and output will be in Fourier space using torch.fft.fft2

        #Don't access the kernel directly. Use the symmetrized variant
        #This kernel is the group average over D4, the symmetry group of a square
        k = self.symmetric_kernel()
        k  = torch.fft.fft2( k )
        
        #Convolve == multiply in Fourier space
        f    = torch.unsqueeze(f,2)  #[b,c1,1,n,n] to make room for c2 dimension
        conv = torch.sum(f*k, dim=1) #convolved f
        
        return conv



    def forward(self, f, fourier_input=False, fourier_output=False ):
        '''
        PURPOSE:
        Fourier convolution

        INPUT:
        f - tensor of size [b,c1,n1,n1]

        fourier_input  - Did you apply torch.fft.fft2 already? Are you in Fourier space?
        fourier_output - Did you want to apply torch.fft.ifft2 before returning?

        OUTPUT:
        
        '''
        

        if f is None:
            return f

        n1 = f.shape[-2]

        #Transform to Fourier space if input isn't already
        if not fourier_input:
            f = torch.fft.fft2( f )

        #Change resolution to n2
        if self.n2 < n1:
            f = self.downsample(f)
        if self.n2 > n1:
            f  = self.upsample(f)
        
        #Output of convolution is in Fourier space
        f  = self.convolution( f )

        #Inverse fft
        if not fourier_output:
            f = torch.fft.ifft2(f)
            
        return f


    def output_dim(self):
        return self.c2